LL introduction



Comparision of different Operations:

| **Operation**             | **Array-Based List**                                                                                               | **Linked List**                                                                                            | **Reasoning**                                                                                                                                                                           |
|---------------------------|--------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Access/Indexing**       | O(1) – Direct indexing is possible.                                                                              | O(n) – Must traverse from the head node.                                                                   | Arrays store elements contiguously in memory allowing direct access; linked lists require sequential traversal to reach an element.                                                     |
| **Search (unsorted)**     | O(n) – Must check each element.                                                                                    | O(n) – Must traverse sequentially.                                                                         | Both structures have to scan elements in the worst-case. Note: a sorted array can use binary search (O(log n)), but linked lists cannot efficiently support binary search.            |
| **Insertion at End**      | Amortized O(1) – Fast if capacity exists; worst-case O(n) when resizing.                                             | O(1) – If a tail pointer is maintained.                                                                    | Arrays can add elements quickly until capacity is exceeded (which then requires a costly resize), while linked lists can append in constant time if the tail is tracked.             |
| **Insertion at Beginning**| O(n) – All elements must be shifted.                                                                               | O(1) – Just update the head pointer.                                                                       | Inserting at the beginning of an array requires shifting all elements to create space; a linked list only needs to update a pointer.                                                     |
| **Insertion in Middle**   | O(n) – Elements after the insertion point must be shifted.                                                         | O(n) – Traversal to the insertion point is needed, but insertion itself is O(1).                             | The cost in arrays is dominated by shifting elements; linked lists pay a traversal cost to reach the point, but then insertion is fast.                                                 |
| **Deletion at End**       | O(1) – Simply reduce the array size.                                                                               | O(n) – For singly linked lists (unless a tail pointer and previous pointer are maintained), O(1) for doubly linked lists with a tail pointer. | Array deletion at the end is simple; in linked lists, if only singly linked without backward pointers, you might need to traverse to update the previous node.                         |
| **Deletion at Beginning** | O(n) – All elements must be shifted left.                                                                          | O(1) – Just update the head pointer.                                                                       | Deleting the first element in an array shifts all subsequent elements; linked lists can quickly remove the head by changing a pointer.                                                 |
| **Deletion in Middle**    | O(n) – Elements after the deletion point must be shifted.                                                          | O(n) – Traversal is required to reach the element, then removal is O(1).                                     | Both require a cost: arrays must shift elements, while linked lists must traverse to the node before deletion.                                                                        |
| **Memory Overhead**       | Low – Only stores the elements.                                                                                    | Higher – Stores additional pointers for each node.                                                         | Arrays are compact in memory; linked lists require extra space for storing pointers along with the data.                                                                              |
| **Cache Locality**        | High – Data is stored contiguously, leading to better cache performance.                                           | Low – Nodes can be scattered in memory.                                                                    | Contiguous memory in arrays improves cache performance, while linked lists may lead to cache misses due to non-sequential memory allocation.                                           |
| **Insertion/Deletion given direct pointer** | Not applicable – Direct pointer manipulation isn’t used in arrays.                                                      | O(1) – If you already have the pointer to the node (and its predecessor, if needed).                        | In linked lists, if you already know the location, you can adjust pointers quickly without additional traversal.                                                                      |




Cache Locality:  

Arrays are stored in contiguous blocks of memory. This means that once you load one element, nearby elements are likely already loaded into the processor's cache due to a phenomenon called spatial locality. When a processor fetches data, it doesn't just fetch one byte or one element; it fetches a block of adjacent memory. As a result, when you access elements in an array sequentially, you're likely to hit the cache, which makes data retrieval much faster.

On the other hand, linked lists are made up of nodes that are typically allocated separately in memory. Because these nodes may be scattered around, accessing one node doesn't guarantee that the next node is already in the cache. This lack of cache locality means that the processor may need to fetch data from slower main memory more often, leading to potential cache misses and, consequently, slower performance.
